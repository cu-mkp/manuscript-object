from typing import List, Tuple, Dict
from lxml import etree as et
from pandas import DataFrame
import os
import sys
from copy import deepcopy
from collections import OrderedDict

import utils
import entry

def ignore_data_path(filepath: str) -> str:
    """Remove the manuscript data path portion from a filepath."""
    return filepath.partition(os.path.commonpath([filepath, utils.manuscript_data_path]))[2]

def extract_folio(filepath: str) -> str:
    """Get the folio out of a filepath which points to a folio XML file.
    E.g. .../tl_p162v_preTEI.xml -> 162v
    """
    return os.path.basename(filepath).split("_")[1][1:] 

def separate_by_id(filepath: str) -> Dict[str, et.Element]:
    """Take a file path, read it as XML, and process it into separate elements by ID.
    Returned object is a dictionary of lxml.etree.Element objects keyed by entry ID as a string.
    Divs without IDs will lumped together into one object keyed by an empty string.
    """
    entries = OrderedDict()

    print(f"Separating divs in file: {ignore_data_path(filepath)}...")
    xml = et.parse(filepath)

    divs = xml.findall("div") # not recursive, which is okay since there should be no nested divs

    for div in divs:
        key = div.get("id") or ""

        if key in entries.keys():
            entries[key].append(div) # add continued entry in-place
        else:
            root = et.Element("entry") # start a new entry with an <entry></entry> element
            root.append(div) # put the current div in the new tree
            entries[key] = root

    print(f"Found {len(entries)} div{'' if len(entries)==1 else 's'} in file {ignore_data_path(filepath)} with ID{'' if len(entries)==1 else 's'}: {', '.join(entries.keys())}.")

    return entries

def generate_entries(directory) -> Dict[str, entry.Entry]:
    """Given the path to a directory of XML files, generate a dictionary of Entry objects keyed by entry ID.
    Entry objects are generated by processing the files into their constituent divs and connecting divs with the same ID together, even across files.
    Divs without IDs are ignored and not included in the returned dict.
    The folio of each entry is considered to be the folio of the first div in the entry.
    """
    print(f"Generating entries from files in folder {directory}...")

    # First, get the XML etree of each entry.
    xml_dict: Dict[str, et.Element] = OrderedDict()
    folios_by_id = {} # Keep track of which folio is associated with each ID.

    for root, _, files in os.walk(directory):
        for filename in files:
            folio = extract_folio(filename)
            entries: Dict[str, et.Element] = separate_by_id(os.path.join(root, filename)) # Process the individual file into a dictionary.

            # Merge individual file's XML etrees with the greater dict of XML etrees.
            # If that ID is already a key in the dict, append all the divs from this file with that ID to the existing XML etree.
            # Otherwise, create a new key-value pair for that ID.
            for identity, xml in entries.items():
                if identity in xml_dict.keys():
                    for div in xml.findall("div"): # Extract divs from xml.
                        xml_dict[identity].append(div) # Append each div.
                elif identity: # Only add it to the dict if it has an ID.
                    xml_dict[identity] = xml
                    folios_by_id[identity] = folio

    # With the entire directory parsed into XML etrees by div, convert each XML etree into an Entry object.
    entries_dict: Dict[str, entry.Entry] = OrderedDict()

    for identity, xml in xml_dict.items():
        folio = folios_by_id[identity]
        print(f"Generating entry with folio {folio}, ID {identity}...")
        entries_dict[identity] = entry.Entry(xml, folio=folio, identity=identity)

    print(f"Generated {len(entries_dict)} entr{'y' if len(entries_dict)==1 else 'ies'}.")
    return entries_dict

def generate_folios(directory) -> Dict[str, entry.Entry]:
    """Given the path to a directory of XML files, generate a dictionary of Entry objects by loading each file as its own entry.
    Values are keyed by filename.
    """
    folios_dict = {}
    for root, _, files in os.walk(directory):
        for filename in files:
            print(f"Generating folio from file {ignore_data_path(os.path.join(root, filename))}...")
            folios_dict[filename] = entry.Entry.from_file(os.path.join(root, filename))
    return folios_dict

class Manuscript():
    def __init__(self, *directories):
        """Given any number of paths to folders with XML files for various manuscript versions, generate a dictionary representing the manuscript, keyed by folder name/version, with the following schema:
            {
                version1 :
                    {ID1 : entry.Entry},
                    {ID2 : entry.Entry},
                    ...,
                version2 :
                    {ID1 : entry.Entry},
                    {ID2 : entry.Entry},
                    ...,
                ...,
            }
        """

        #TODO: implement specifying a range of entries you want, like so:
        # entries: Union[bool, List[str]]=True
        # entries: a list or a boolean describing which entries to load
        #          True means all; False or [] means none; a list of entry IDs and/or folios only loads those
        # TODO: allow ranges of entries and folios to be specified like 007v..014r
        # TODO: allow ints
        # TODO: allow excluding leading 0s

        print(f"Generating Manuscript object for versions {','.join([os.path.basename(directory) for directory in directories])}...")
        self.entries = {}
        self.folios = {}
        self.directories = {}
        self.versions = []
        for directory in directories:
            version = os.path.basename(directory)
            self.entries[version] = generate_entries(directory)
            self.folios[version] = generate_folios(directory)
            self.directories[version] = directory
            self.versions.append(version)

    # TODO: write a search method

    def update(self):
        self.update_metadata()
        self.update_ms_txt()
        self.update_entries()
        self.update_all_folios()

    def update_ms_txt(self):
        """Update /m-k-manuscript-data/update_ms/ with the current manuscript from /ms-xml/.
        Iterate through /ms-xml/ for each version, remove tags, and save to /ms-txt/.
        """
        for version, folios_dict in self.folios.items():
            for filename, folio in folios_dict.items():
                outfile = os.path.join(utils.manuscript_data_path, "ms-txt", version, filename.replace("xml", "txt"))
                os.makedirs(os.path.dirname(outfile), exist_ok=True)
                with open(outfile, 'w') as fp:
                    print(f"Writing folio {version}_{extract_folio(filename)} to {ignore_data_path(outfile)}...")
                    fp.write(folio.text)


    def update_entries(self):
        """Update /m-k-manuscript-data/entries/ with the current manuscript from /ms-xml/."""

        txt_dir = os.path.join(utils.manuscript_data_path, "entries", "txt")
        xml_dir = os.path.join(utils.manuscript_data_path, "entries", "xml")

        for version, entries in self.entries.items():
            txt_path = os.path.join(txt_dir, version)
            xml_path = os.path.join(xml_dir, version)
            os.makedirs(txt_path, exist_ok=True)
            os.makedirs(xml_path, exist_ok=True)

            for identity, entry in entries.items():
                filepath_txt = os.path.join(txt_path, f'{version}_{entry.identity}.txt')
                filepath_xml = os.path.join(xml_path, f'{version}_{entry.identity}.xml')

                content_txt = entry.text
                content_xml = entry.xml_string # should already have an <entry> root tag :)

                with open(filepath_txt, 'w', encoding='utf-8') as fp:
                    print(f"Writing entry {entry.identity} {version} txt to {ignore_data_path(filepath_txt)}...")
                    fp.write(content_txt)

                with open(filepath_xml, 'w', encoding='utf-8') as fp:
                    print(f"Writing entry {entry.identity} {version} xml to {ignore_data_path(filepath_xml)}...")
                    fp.write(content_xml)

    def update_all_folios(self):
        """Update /m-k-manuscript-data/allFolios/ with the current manuscript from /ms-xml/."""
        txt_dir = os.path.join(utils.manuscript_data_path, "allFolios", "txt")
        xml_dir = os.path.join(utils.manuscript_data_path, "allFolios", "xml")

        for version in self.versions:
            content_txt = self.generate_all_folios(method="txt", version=version)
            content_xml = self.generate_all_folios(method="xml", version=version)

            txt_path = os.path.join(txt_dir, version)
            xml_path = os.path.join(xml_dir, version)
            os.makedirs(txt_path, exist_ok=True)
            os.makedirs(xml_path, exist_ok=True)

            filepath_txt = os.path.join(txt_path, f"all_{version}.txt")
            filepath_xml = os.path.join(xml_path, f"all_{version}.xml")

            with open(filepath_txt, 'w', encoding='utf-8') as fp:
                print(f"Writing allFolios {version} txt to {ignore_data_path(filepath_txt)}...")
                fp.write(content_txt)

            with open(filepath_xml, 'w', encoding='utf-8') as fp:
                print(f"Writing allFolios {version} xml to {ignore_data_path(filepath_xml)}...")
                fp.write(content_xml)

    def generate_all_folios(self, method="txt", version="tl"):
        """Generate a single txt or xml file containing the content of each file (i.e. folio) of a given version in sequence.
        `method` may be "txt" or "xml".
        """
        if method=="txt":
            content = "" # string representing the entire text version
            for filename, folio in self.folios[version].items():
                print(f"Adding folio {extract_folio(filename)} to allFolios {version} {method}...")
                content += folio.text + "\n\n"

        elif method=="xml":
            root = et.Element("all") # root element to wrap the entire xml string
            for filename, folio in self.folios[version].items():
                print(f"Adding folio {extract_folio(filename)} to allFolios {version} {method}...")
                list_of_divs = folio.xml.findall("div")
                divs = [deepcopy(div) for div in list_of_divs] # avoid modifying instance variables
                root.extend(divs) # add children of <entry> element
            content = entry.to_xml_string(root)

        else:
            raise Exception(f"Invalid method: '{method}'. Methods: txt, xml")

        return content

    def update_metadata(self):
        """Write a metadata file containing information about each entry."""
        df = self.generate_metadata()
        df.drop(columns=self.versions, inplace=True) # this is just memory addresses
        outfile = os.path.join(utils.manuscript_data_path, "metadata", "entry_metadata.csv")
        print(f"Writing metadata to {ignore_data_path(outfile)}...")
        df.to_csv(outfile, index=False)

    def generate_metadata(self):
        """Update /m-k-manuscript-data/metadata/entry_metadata.csv with the current manuscript. Create a Pandas DataFrame
        indexed by entry. Create data columns, and remove the column that contains the entry objects. Save file.
        """
        print("Generating metadata...")
        df = DataFrame(columns=self.versions, data=self.entries)
        df['folio'] = df.tl.apply(lambda x: x.folio)
        df['folio_display'] = df.folio.apply(lambda x: x.lstrip('0')) # remove leading zeros
        df['div_id'] = df.tl.apply(lambda x: x.identity)
        df['categories'] = df.tl.apply(lambda x: (';'.join(x.categories)))
        for version in self.versions:
            df[f'heading_{version}'] = df[version].apply(lambda x: x.title)
        for prop, tag in utils.prop_dict.items():
            for version in self.versions:
                df[f'{tag}_{version}'] = df[version].apply(lambda x: ';'.join(x.properties[prop]))

        return df
