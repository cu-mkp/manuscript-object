from typing import List, Tuple, Dict
from lxml import etree as et
from pandas import DataFrame
import os
import sys
from copy import deepcopy
from collections import OrderedDict

import utils
import entry

def ignore_data_path(filepath: str) -> str:
    """Remove the manuscript data path portion from a filepath."""
    return filepath.partition(os.path.commonpath([filepath, utils.manuscript_data_path]))[2]

def extract_folio(filepath: str) -> str:
    """Get the folio out of a filepath which points to a folio XML file.
    E.g. .../tl_p162v_preTEI.xml -> 162v
    """
    return os.path.basename(filepath).split("_")[1][1:] 

def separate_by_id(filepath: str) -> Dict[str, et.Element]:
    """Take a file path, read it as XML, and process it into separate elements by ID.
    Returned object is a dictionary of lxml.etree.Element objects keyed by entry ID as a string.
    Divs without IDs will lumped together into one object keyed by an empty string.
    """
    folio = extract_folio(filepath)
    entries = OrderedDict()

    print(f"Separating divs in file: {ignore_data_path(filepath)}...")
    xml = et.parse(filepath)

    divs = xml.findall("div") # not recursive, which is okay since there should be no nested divs

    for div in divs:
        key = div.get("id") or ""

        if key in entries.keys():
            entries[key].append(div) # add continued entry in-place
        else:
            root = et.Element("entry") # start a new entry with an <entry></entry> element
            root.append(div) # put the current div in the new tree
            entries[key] = root

    print(f"Found {len(entries)} div{'' if len(entries)==1 else 's'} in file {ignore_data_path(filepath)} with ID{'' if len(entries)==1 else 's'}: {', '.join(entries.keys())}.")

    return entries

def generate_manuscript(directory) -> Dict[str, entry.Entry]:
    """Given the path to a directory of XML files, generate a dictionary of Entry objects keyed by entry ID.
    Entry objects are generated by processing the files into their constituent divs and connecting divs with the same ID together, even across files.
    Divs without IDs are ignored and not included in the returned dict.
    """
    print(f"Generating entries from files in folder {directory}...")

    # First, get the XML etree of each entry.
    xml_dict: Dict[str, et.Element] = OrderedDict()

    for root, _, files in os.walk(directory):
        for filename in files:
            folio = extract_folio(filename)
            entries: Dict[str, et.Element] = separate_by_id(os.path.join(root, filename)) # Process the individual file into a dictionary.

            # Merge individual file's XML etrees with the greater dict of XML etrees.
            # If that ID is already a key in the dict, append all the divs from this file with that ID to the existing XML etree.
            # Otherwise, create a new key-value pair for that ID.
            for identity, xml in entries.items():
                if identity in xml_dict.keys():
                    for div in xml.findall("div"): # Extract divs from xml.
                        xml_dict[identity].append(div) # Append each div.
                elif identity: # Only add it to the dict if it has an ID.
                    xml_dict[identity] = xml

    # With the entire directory parsed into XML etrees by div, convert each XML etree into an Entry object.
    entries_dict: Dict[str, entry.Entry] = OrderedDict()

    for identity, xml in xml_dict.items():
        print(f"Generating entry with folio {folio}, ID {identity}...")
        entries_dict[identity] = Entry(xml, folio=folio, identity=identity)

    print(f"Generated {len(entries_dict)} entr{'y' if len(entries_dict)==1 else 'ies'}.")
    return entries_dict


class Manuscript():
    def __init__(self, directory):
        """Given a path to a directory containing folders with XML files for various manuscript versions, generate a dictionary representing the manuscript, keyed by version, with the following schema:
            {
                version1 :
                    {ID1 : entry.Entry},
                    {ID2 : entry.Entry},
                    ...,
                version2 :
                    {ID1 : entry.Entry},
                    {ID2 : entry.Entry},
                    ...,
                ...,
            }
        """

        #TODO: implement specifying a range of entries you want, like so:
        # entries: Union[bool, List[str]]=True
        # entries: a list or a boolean describing which entries to load
        #          True means all; False or [] means none; a list of entry IDs and/or folios only loads those
        # TODO: allow ranges of entries and folios to be specified like 007v..014r
        # TODO: allow ints
        # TODO: allow excluding leading 0s

        print(f"Generating Manuscript object from {directory}...")
        self.entries = {}
        for version in utils.versions:
            self.entries[version] = generate_manuscript(os.path.join(directory, version))

        # TODO: give less confusing names to these two instance variables
        self.directory = directory
        self.data_path = os.path.dirname(directory) # one up from given data directory

    # TODO: write a search method

    def update(self):
        self.update_metadata()
        self.update_ms_txt()
        self.update_entries()
        self.update_all_folios()

    def update_ms_txt(self):
        """
        Update /m-k-manuscript-data/update_ms/ with the current manuscript from /ms-xml/.
        Iterate through /ms-xml/ for each version, remove tags, and save to /ms-txt/.
        """
        for version, folios_dict in self.generate_folios().items():
            for filename, folio in folios_dict.items():
                outfile = os.path.join(self.data_path, "ms-txt", version, filename.replace("xml", "txt"))
                os.makedirs(os.path.dirname(outfile), exist_ok=True)
                with open(outfile, 'w') as fp:
                    print(f"Writing folio {version}_{extract_folio(filename)} to {ignore_data_path(outfile)}...")
                    fp.write(folio.text)

    def generate_folios(self):
        # TODO: specify a version for this
        versions = {}
        for version in utils.versions:
            folios_dict = {}
            for root, _, files in os.walk(os.path.join(self.directory, version)):
                for filename in files:
                    # I'm making this simple at the sacrifice of a tiny bit of speed
                    # Forgive me
                    # TODO: make entry.py do this with a module function called from the classmethod so there's one universal place to generate an Entry etree from a file (we already have one for from a string: generate_etree()!)
                    print(f"Generating entry from file {ignore_data_path(os.path.join(root, filename))}...")
                    folios_dict[filename] = Entry.from_file(os.path.join(root, filename))
            versions[version] = folios_dict
        return versions

    def update_entries(self):
        """
        Update /m-k-manuscript-data/entries/ with the current manuscript from /ms-xml/.
        """

        txt_dir = os.path.join(self.data_path, "entries", "txt")
        xml_dir = os.path.join(self.data_path, "entries", "xml")

        for version in utils.versions:
            txt_path = os.path.join(txt_dir, version)
            xml_path = os.path.join(xml_dir, version)
            os.makedirs(txt_path, exist_ok=True)
            os.makedirs(xml_path, exist_ok=True)

            for identity, entry in self.entries[version].items():
                filepath_txt = os.path.join(txt_path, f'{version}_{entry.identity}.txt')
                filepath_xml = os.path.join(xml_path, f'{version}_{entry.identity}.xml')

                content_txt = entry.text
                content_xml = entry.xml_string # should already have an <entry> root tag :)

                with open(filepath_txt, 'w', encoding='utf-8') as fp:
                    print(f"Writing entry {entry.identity} {version} txt to {ignore_data_path(filepath_txt)}...")
                    fp.write(content_txt)

                with open(filepath_xml, 'w', encoding='utf-8') as fp:
                    print(f"Writing entry {entry.identity} {version} xml to {ignore_data_path(filepath_xml)}...")
                    fp.write(content_xml)

    def update_all_folios(self):
        """
        Update /m-k-manuscript-data/allFolios/ with the current manuscript from /ms-xml/.
        """
        txt_dir = os.path.join(self.data_path, "allFolios", "txt")
        xml_dir = os.path.join(self.data_path, "allFolios", "xml")

        for version in utils.versions:
            content_txt = self.generate_all_folios(method="txt", version=version)
            content_xml = self.generate_all_folios(method="xml", version=version)

            txt_path = os.path.join(txt_dir, version)
            xml_path = os.path.join(xml_dir, version)
            os.makedirs(txt_path, exist_ok=True)
            os.makedirs(xml_path, exist_ok=True)

            filepath_txt = os.path.join(txt_path, f"all_{version}.txt")
            filepath_xml = os.path.join(xml_path, f"all_{version}.xml")

            with open(filepath_txt, 'w', encoding='utf-8') as fp:
                print(f"Writing allFolios {version} txt to {ignore_data_path(filepath_txt)}...")
                fp.write(content_txt)

            with open(filepath_xml, 'w', encoding='utf-8') as fp:
                print(f"Writing allFolios {version} xml to {ignore_data_path(filepath_xml)}...")
                fp.write(content_xml)

    def generate_all_folios(self, method="txt", version="tl"):
        # method: "txt" or "xml"
        # version: "tc", "tcn", or "tl"
        folios_dict = self.generate_folios()[version]

        if method=="txt":
            content = "" # string representing the entire text version
            for filename, folio in folios_dict.items():
                print(f"Adding folio {extract_folio(filename)} to allFolios {version} {method}...")
                content += folio.text + "\n\n"

        elif method=="xml":
            root = et.Element("all") # root element to wrap the entire xml string
            for filename, folio in folios_dict.items():
                print(f"Adding folio {extract_folio(filename)} to allFolios {version} {method}...")
                list_of_divs = folio.xml.findall("div")
                divs = [deepcopy(div) for div in list_of_divs] # avoid modifying instance variables
                root.extend(divs) # add children of <entry> element
            content = to_xml_string(root)

        else:
            raise Exception(f"Invalid method: '{method}'. Methods: txt, xml")

        return content

    def update_metadata(self):
        df = self.generate_metadata()
        df.drop(columns=utils.versions, inplace=True) # this is just memory addresses
        outfile = os.path.join(self.data_path, "metadata", "entry_metadata.csv")
        print(f"Writing metadata to {ignore_data_path(outfile)}...")
        df.to_csv(outfile, index=False)

    def generate_metadata(self):
        """
        Update /m-k-manuscript-data/metadata/entry_metadata.csv with the current manuscript. Create a Pandas DataFrame
        indexed by entry. Create data columns, and remove the column that contains the entry objects. Save File.
        """
        print("Generating metadata...")
        # for making entry-metadata.csv
        # use tl version for basic info
        # TODO: this is almost identical to Matthew's code; can be we improve on it at all?
        df = DataFrame(columns=utils.versions, data=self.entries)
        df['folio'] = df.tl.apply(lambda x: x.folio)
        df['folio_display'] = df.folio.apply(lambda x: x.lstrip('0')) # remove leading zeros
        df['div_id'] = df.tl.apply(lambda x: x.identity)
        df['categories'] = df.tl.apply(lambda x: (';'.join(x.categories)))
        for version in utils.versions:
            df[f'heading_{version}'] = df[version].apply(lambda x: x.title)
        for prop, tag in utils.prop_dict.items():
            for version in utils.versions:
                df[f'{tag}_{version}'] = df[version].apply(lambda x: ';'.join(x.properties[prop]))

        return df
